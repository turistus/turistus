/* Zepto v1.2.0 - formulário ajax do evento zepto, ou seja, - zeptojs.com/license */
(função(global, fábrica) {
    if (typeof define === 'função' && define.amd)
      define(função() { return fábrica(global) })
    outro
      fábrica (global)
  }(this, function(janela) {
    var Zepto = (function() {
    var indefinido, chave, $, classList, emptyArray = [], concat = emptyArray.concat, filtro = emptyArray.filter, fatia = emptyArray.slice,
      documento = janela.documento,
      elementDisplay = {}, classCache = {},
      cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom' : 1 },
      fragmentRE = /^\s*<(\w+|!)[^>]*>/,
      singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
      tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
      rootNodeRE = /^(?:body|html)$/i,
      capitalRE = /([AZ])/g,

      // atributos especiais que devem ser obtidos/configurados por meio de chamadas de método
      methodAttributes = ['val', 'css', 'html', 'texto', 'dados', 'largura', 'altura', 'deslocamento'],

      adjacencyOperators = [ 'depois', 'prepend', 'antes', 'acrescentar' ],
      tabela = document.createElement('tabela'),
      tableRow = document.createElement('tr'),
      recipientes = {
        'tr': document.createElement('tbody'),
        'tbody': mesa, 'thead': mesa, 'tfoot': mesa,
        'td': tabelaLinha, 'th': tabelaLinha,
        '*': document.createElement('div')
      },
      readyRE = /complete|carregado|interativo/,
      simplesSeletorRE = /^[\w-]*$/,
      classe2tipo = {},
      toString = class2type.toString,
      zepto = {},
      camelizar, uniq,
      tempParent = document.createElement('div'),
      propMap = {
        'tabindex': 'tabIndex',
        'somente leitura': 'somente leitura',
        'para': 'htmlPara',
        'classe': 'className',
        'comprimento máximo': 'comprimento máximo',
        'espaço celular': 'espaço celular',
        'cellpadding': 'cellPadding',
        'linhas': 'linhas',
        'colspan': 'colSpan',
        'usemap': 'useMap',
        'frameborder': 'frameBorder',
        'conteúdoeditável': 'conteúdoeditável'
      },
      isArray = Array.isArray ||
        função(objeto){ retorna a instância do objeto Array }

    zepto.matches = function(elemento, seletor) {
      if (!selector || !element || element.nodeType !== 1) return false
      var matchSelector = element.matches || element.webkitMatchesSelector ||
                            element.mozMatchesSelector || elemento.oMatchesSelector ||
                            element.matchesSelector
      if (matchesSelector) return matchsSelector.call(elemento, seletor)
      // volta a executar um seletor:
      var match, parent = element.parentNode, temp = !parent
      if (temp) (pai = tempParent).appendChild(elemento)
      correspondência = ~zepto.qsa(pai, seletor).indexOf(elemento)
      temp && tempParent.removeChild(elemento)
      partida de volta
    }

    tipo de função(obj) {
      return obj == null ? String(obj):
        class2type[toString.call(obj)] || "objeto"
    }

    function isFunction(value) { return type(value) == "function" }
    function isWindow(obj) { return obj != null && obj == obj.window }
    function isDocument(obj) { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }
    function isObject(obj) { return type(obj) == "objeto" }
    function isPlainObject(obj) {
      return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype
    }

    function likeArray(obj) {
      var length = !!obj && 'comprimento' in obj && obj.length,
        tipo = $.tipo(obj)

      return 'função' != tipo && !isWindow(obj) && (
        'array' == tipo || comprimento === 0 ||
          (tipo de comprimento == 'número' && comprimento > 0 && (comprimento - 1) em obj)
      )
    }

    function compact(array) { return filter.call(array, function(item){ return item != null }) }
    function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], matriz): matriz }
    camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }
    function dasherize(str) {
      return str.replace(/::/g, '/')
             .replace(/([AZ]+)([AZ][az])/g, '$1_$2')
             .replace(/([az\d])([AZ])/g, '$1_$2')
             .replace(/_/g, '-')
             .toLowerCase()
    }
    uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }

    função classeRE(nome) {
      nome de retorno em classCache?
        classCache[nome] : (classCache[nome] = new RegExp('(^|\\s)' + nome + '(\\s|$)'))
    }

    function mayAddPx(nome, valor) {
      return (typeof value == "number" && !cssNumber[dasherize(name)]) ? valor + "px": valor
    }

    function defaultDisplay(nodeName) {
      elemento var, exibição
      if (!elementDisplay[nodeName]) {
        element = document.createElement(nodeName)
        document.body.appendChild(elemento)
        display = getComputedStyle(elemento, '').getPropertyValue("display")
        element.parentNode.removeChild(elemento)
        exibição == "nenhum" && (exibição = "bloco")
        elementoDisplay[nodeName] = exibição
      }
      return elementDisplay[nodeName]
    }

    função filhos(elemento) {
      retorna 'crianças' no elemento ?
        slice.call(element.children):
        $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })
    }

    function Z(dom, seletor) {
      var i, len = dom ? dom.length: 0
      for (i = 0; i < len; i++) this[i] = dom[i]
      this.length = len
      this.seletor = seletor || ''
    }

    // `$.zepto.fragment` recebe uma string html e um nome de tag opcional
    // para gerar nós DOM a partir da string html fornecida.
    // Os nós DOM gerados são retornados como um array.
    // Esta função pode ser substituída em plugins, por exemplo, para fazer
    // é compatível com navegadores que não suportam totalmente o DOM.
    zepto.fragment = function(html, nome, propriedades) {
      var dom, nós, contêiner

      // Uma otimização de caso especial para uma única tag
      if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))

      if (!dom) {
        if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>")
        if (nome === indefinido) nome = fragmentRE.test(html) && RegExp.$1
        if (!(nome em contêineres)) nome = '*'

        contêiner = contêineres[nome]
        container.innerHTML = '' + html
        dom = $.each(slice.call(container.childNodes), function(){
          container.removeChild(this)
        })
      }

      if (isPlainObject(propriedades)) {
        nodos = $(dom)
        $.each(propriedades, função(chave, valor) {
          if (methodAttributes.indexOf(chave) > -1) nós[chave](valor)
          else nodes.attr(chave, valor)
        })
      }

      retornar dom
    }

    // `$.zepto.Z` troca o protótipo do array `dom` dado
    // de nós com `$.fn` e assim fornecendo todas as funções Zepto
    // para a matriz. Este método pode ser substituído em plugins.
    zepto.Z = function(dom, seletor) {
      return novo Z(dom, seletor)
    }

    // `$.zepto.isZ` deve retornar `true` se o objeto fornecido for um Zepto
    // coleção. Este método pode ser substituído em plugins.
    zepto.isZ = function(objeto) {
      retorna a instância do objeto de zepto.Z
    }

    // `$.zepto.init` é a contraparte do Zepto para `$.fn.init` do jQuery e
    // pega um seletor CSS e um contexto opcional (e lida com vários
    // casos especiais).
    // Este método pode ser substituído em plugins.
    zepto.init = function(seletor, contexto) {
      var dom
      // Se nada for fornecido, retorna uma coleção Zepto vazia
      if (!seletor) return zepto.Z()
      // Otimizar para seletores de string
      else if (tipo de seletor == 'string') {
        seletor = seletor.trim()
        // Se for um fragmento html, crie nós a partir dele
        // Observação: no Chrome 21 e no Firefox 15, erro DOM 12
        // é lançado se o fragmento não começar com <
        if (seletor[0] == '<' && fragmentRE.test(seletor))
          dom = zepto.fragment(seletor, RegExp.$1, contexto), seletor = nulo
        // Se houver um contexto, crie uma coleção nesse contexto primeiro e selecione
        // nós de lá
        else if (contexto !== indefinido) return $(contexto).find(seletor)
        // Se for um seletor CSS, use-o para selecionar nós.
        else dom = zepto.qsa(documento, seletor)
      }
      // Se uma função for fornecida, chame-a quando o DOM estiver pronto
      else if (isFunction(seletor)) return $(document).ready(seletor)
      // Se for dada uma coleção Zepto, basta devolvê-la
      else if (zepto.isZ(seletor)) return seletor
      outro {
        // normaliza a matriz se uma matriz de nós for fornecida
        if (isArray(seletor)) dom = compact(seletor)
        // Envolve os nós DOM.
        else if (isObject(seletor))
          dom = [seletor], seletor = nulo
        // Se for um fragmento html, crie nós a partir dele
        else if (fragmentRE.test(seletor))
          dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null
        // Se houver um contexto, crie uma coleção nesse contexto primeiro e selecione
        // nós de lá
        else if (contexto !== indefinido) return $(contexto).find(seletor)
        // E por último, mas não menos importante, se for um seletor CSS, use-o para selecionar nós.
        else dom = zepto.qsa(documento, seletor)
      }
      // cria uma nova coleção Zepto a partir dos nós encontrados
      return zepto.Z(dom, seletor)
    }

    // `$` será o objeto base `Zepto`. Ao chamar isso
    // a função apenas chama `$.zepto.init, que torna a implementação
    // detalhes de seleção de nós e criação de coleções Zepto
    // patchable em plugins.
    $ = função(seletor, contexto){
      return zepto.init(seletor, contexto)
    }

    function extend(alvo, origem, profundidade) {
      para (chave na fonte)
        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
          if (isPlainObject(source[key]) && !isPlainObject(target[key]))
            alvo[chave] = {}
          if (isArray(fonte[chave]) && !isArray(destino[chave]))
            alvo[chave] = []
          extend(target[key], source[key], deep)
        }
        else if (origem[chave] !== indefinido) destino[chave] = origem[chave]
    }

    // Copia todas as propriedades, exceto as indefinidas, de um ou mais
    // objetos para o objeto `target`.
    $.extend = function(alvo){
      var deep, args = slice.call(argumentos, 1)
      if (tipo de alvo == 'booleano') {
        profundo = alvo
        alvo = args.shift()
      }
      args.forEach(function(arg){ extend(target, arg, deep) })
      alvo de retorno
    }

    // `$.zepto.qsa` é a implementação do seletor CSS do Zepto que
    // usa `document.querySelectorAll` e otimiza para alguns casos especiais, como `#id`.
    // Este método pode ser substituído em plugins.
    zepto.qsa = function(elemento, seletor){
      var encontrado,
          talvezID = seletor[0] == '#',
          talvezClasse = !talvezID && seletor[0] == '.',
          nameOnly = talvezID || talvezClasse? selector.slice(1) : selector, // Certifique-se de que um nome de tag de 1 caractere ainda seja verificado
          isSimple = simpleSelectorRE.test(nameOnly)
      return (element.getElementById && isSimple && MaybeID) ? // Safari DocumentFragment não tem getElementById
        ((encontrado = element.getElementById(nameOnly)) ? [encontrado]: [] ):
        (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :
        fatia.chamada(
          isSimple && !talvezID && element.getElementsByClassName ? // DocumentFragment não tem getElementsByClassName/TagName
            talvezClasse? element.getElementsByClassName(nameOnly): // Se for simples, pode ser uma classe
            element.getElementsByTagName(selector): // Ou uma tag
            element.querySelectorAll(selector) // Ou não é simples, e precisamos consultar todos
        )
    }

    função filtrada(nós, seletor) {
      seletor de retorno == null ? $(nós) : $(nós).filter(seletor)
    }

    $.contains = document.documentElement.contains ?
      função(pai, nó) {
        return parent !== node && parent.contains(node)
      } :
      função(pai, nó) {
        while (node ​​&& (node ​​= node.parentNode))
          if (nó === pai) retornar verdadeiro
        retorna falso
      }

    function funcArg(contexto, arg, idx, payload) {
      return isFunction(arg) ? arg.call(contexto, idx, payload): arg
    }

    function setAttribute(nó, nome, valor) {
      valor == nulo? node.removeAttribute(nome) : node.setAttribute(nome, valor)
    }

    // acessa a propriedade className respeitando SVGAnimatedString
    function className(nó, valor){
      var klass = node.className || '',
          svg = classe && classe.baseVal !== indefinido

      if (valor === indefinido) return svg ? classe.baseVal: classe
      svg? (klass.baseVal = valor) : (node.className = valor)
    }

    // "verdadeiro" => verdadeiro
    // "falso" => falso
    // "nulo" => nulo
    // "42" => 42
    // "42.5" => 42.5
    // "08" => "08"
    // JSON => analisa se válido
    // String => self
    function desserializeValue(valor) {
      tentar {
        valor de retorno ?
          valor == "verdadeiro" ||
          (valor == "falso" ? falso:
            valor == "nulo" ? nulo :
            +valor + "" == valor ? +valor:
            /^[\[\{]/.test(valor) ? $.parseJSON(valor):
            valor )
          : valor
      } pegar(e) {
        valor de retorno
      }
    }

    $.tipo = tipo
    $.isFunction = isFunction
    $.isWindow = isWindow
    $.isArray = isArray
    $.isPlainObject = isPlainObject

    $.isEmptyObject = function(obj) {
      nome da var
      for (nome em obj) return false
      retornar verdadeiro
    }

    $.isNumeric = function(val) {
      var num = Number(val), type = typeof val
      return val != null && type != 'boolean' &&
        (tipo != 'string' || val.length) &&
        !isNaN(num) && isFinite(num) || falso
    }

    $.inArray = function(elem, array, i){
      return emptyArray.indexOf.call(array, elem, i)
    }

    $.camelCase = camelize
    $.trim = function(str) {
      return str == null ? "" : String.prototype.trim.call(str)
    }

    // compatibilidade de plugins
    $.uuid = 0
    $.suporte = { }
    $.expr = { }
    $.noop = função() {}

    $.map = function(elementos, callback){
      valor var, valores = [], i, chave
      if (likeArray(elementos))
        for (i = 0; i < elementos.comprimento; i++) {
          valor = callback(elementos[i], i)
          if (valor != nulo) valores.push(valor)
        }
      outro
        for (chave nos elementos) {
          value = callback(elementos[chave], chave)
          if (valor != nulo) valores.push(valor)
        }
      return flatten(valores)
    }

    $.each = function(elementos, callback){
      var i, chave
      if (likeArray(elementos)) {
        for (i = 0; i < elementos.comprimento; i++)
          if (callback.call(elements[i], i, elements[i]) === false) return elementos
      } outro {
        for (chave nos elementos)
          if (callback.call(elementos[chave], chave, elementos[chave]) === false) elementos de retorno
      }

      elementos de retorno
    }

    $.grep = function(elementos, callback){
      return filter.call(elements, callback)
    }

    if (window.JSON) $.parseJSON = JSON.parse

    // Preenche o mapa class2type
    $.each("Número Booleano String Function Array Date RegExp Object Error".split(" "), function(i, name) {
      class2type[ "[objeto " + nome + "]" ] = nome.toLowerCase()
    })

    // Define os métodos que estarão disponíveis em todos
    // Coleções Zepto
    $.fn = {
      construtor: zepto.Z,
      comprimento: 0,

      // Porque uma coleção age como um array
      // copia essas funções úteis de array.
      forEach: emptyArray.forEach,
      reduzir: emptyArray.reduce,
      push: emptyArray.push,
      sort: emptyArray.sort,
      emenda: emptyArray.splice,
      indexOf: emptyArray.indexOf,
      concat: function(){
        var i, valor, args = []
        for (i = 0; i < argumentos.comprimento; i++) {
          valor = argumentos[i]
          args[i] = zepto.isZ(valor) ? valor.toArray(): valor
        }
        return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)
      },

      // `map` e `slice` na API jQuery funcionam de forma diferente
      // de suas contrapartes de matriz
      mapa: function(fn){
        return $($.map(this, function(el, i){ return fn.call(el, i, el) }))
      },
      fatia: função(){
        return $(slice.apply(this, argumentos))
      },

      pronto: function(callback){
        // precisa verificar se document.body existe para o IE conforme o navegador relata
        // documento pronto quando ainda não criou o elemento body
        if (readyRE.test(document.readyState) && document.body) callback($)
        else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)
        devolva isso
      },
      obter: function(idx){
        return idx === indefinido? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]
      },
      toArray: function(){ return this.get() },
      tamanho: function(){
        retorne este.comprimento
      },
      remover: função(){
        return this.each(function(){
          if (this.parentNode != null)
            this.parentNode.removeChild(this)
        })
      },
      cada: function(callback){
        emptyArray.every.call(this, function(el, idx){
          return callback.call(el, idx, el) !== false
        })
        devolva isso
      },
      filtro: função(seletor){
        if (isFunction(seletor)) return this.not(this.not(seletor))
        return $(filter.call(this, function(element){
          return zepto.matches(elemento, seletor)
        }))
      },
      add: function(seletor,contexto){
        return $(uniq(this.concat($(seletor,contexto))))
      },
      é: function(seletor){
        return this.length > 0 && zepto.matches(this[0], seletor)
      },
      not: function(seletor){
        var nós=[]
        if (isFunction(seletor) && selector.call !== indefinido)
          this.each(função(idx){
            if (!selector.call(this,idx)) nodes.push(this)
          })
        outro {
          var exclui = seletor de tipo == 'string'? this.filter(seletor):
            (likeArray(seletor) && isFunction(seletor.item)) ? slice.call(seletor) : $(seletor)
          this.forEach(função(el){
            if (exclui.indexOf(el) < 0) nodes.push(el)
          })
        }
        retornar $(nós)
      },
      tem: função(seletor){
        return this.filter(function(){
          return isObject(seletor) ?
            $.contains(this, selector):
            $(this).find(seletor).size()
        })
      },
      eq: function(idx){
        return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)
      },
      primeiro: função(){
        var el = this[0]
        return el && !isObject(el) ? el: $(el)
      },
      último: function(){
        var el = this[this.length - 1]
        return el && !isObject(el) ? el: $(el)
      },
      localizar: function(seletor){
        var resultado, $this = this
        if (!seletor) resultado = $()
        else if (seletor typeof == 'objeto')
          resultado = $(seletor).filter(função(){
            nó var = este
            return emptyArray.some.call($this, function(parent){
              return $.contains(pai, nó)
            })
          })
        else if (this.length == 1) resultado = $(zepto.qsa(this[0], seletor))
        else result = this.map(function(){ return zepto.qsa(this, selector) })
        resultado de retorno
      },
      mais próximo: função(seletor, contexto){
        var nodes = [], coleção = typeof seletor == 'objeto' && $(seletor)
        this.each(função(_, nó){
          while (nó && !(coleção ? coleção.indexOf(nó) >= 0 : zepto.matches(nó, seletor)))
            node = node !== context && !isDocument(node) && node.parentNode
          if (node ​​&& nodes.indexOf(node) < 0) nodes.push(node)
        })
        retornar $(nós)
      },
      pais: function(seletor){
        var ancestrais = [], nós = este
        while (nós.comprimento > 0)
          nós = $.map(nós, função(nó){
            if ((node ​​= node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
              ancestrais.push(nó)
              nó de retorno
            }
          })
        return filtrado(ancestrais, seletor)
      },
      pai: function(seletor){
        return filtrado(uniq(this.pluck('parentNode')), seletor)
      },
      filhos: function(seletor){
        return filtrado(this.map(function(){ return children(this) }), seletor)
      },
      conteudo: function() {
        return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })
      },
      irmãos: function(seletor){
        return filtrado(this.map(function(i, el){
          return filter.call(children(el.parentNode), function(child){ return child!==el })
        }), seletor)
      },
      vazio: função(){
        return this.each(function(){ this.innerHTML = '' })
      },
      // `pluck` é emprestado de Prototype.js
      arrancar: função(propriedade){
        return $.map(this, function(el){ return el[propriedade] })
      },
      mostre: função(){
        return this.each(function(){
          this.style.display == "nenhum" && (this.style.display = '')
          if (getComputedStyle(this, '').getPropertyValue("display") == "nenhum")
            this.style.display = defaultDisplay(this.nodeName)
        })
      },
      replaceWith: function(newContent){
        return this.before(newContent).remove()
      },
      wrap: function(estrutura){
        var func = isFunction(estrutura)
        if (this[0] && !func)
          var dom = $(estrutura).get(0),
              clone = dom.parentNode || this.length > 1

        return this.each(função(índice){
          $(este).wrapAll(
            função? structure.call(this, index):
              clonar? dom.cloneNode(true): dom
          )
        })
      },
      wrapAll: function(estrutura){
        if (este[0]) {
          $(este[0]).antes(estrutura = $(estrutura))
          filhos var
          // detalha até o elemento mais interno
          while ((filhos = estrutura.filhos()).comprimento) estrutura = filhos.primeiro()
          $(estrutura).append(isto)
        }
        devolva isso
      },
      wrapInner: função(estrutura){
        var func = isFunction(estrutura)
        return this.each(função(índice){
          var self = $(this), content = self.contents(),
              dom = função ? structure.call(this, index): estrutura
          content.length ? content.wrapAll(dom) : self.append(dom)
        })
      },
      desempacotar: function(){
        this.parent().each(function(){
          $(este).replaceWith($(este).filhos())
        })
        devolva isso
      },
      clonar: função(){
        return this.map(function(){ return this.cloneNode(true) })
      },
      ocultar: função(){
        return this.css("exibir", "nenhum")
      },
      alternar: função(configuração){
        return this.each(function(){
          var el = $(este)
          ;(configuração === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide()
        })
      },
      prev: function(seletor){ return $(this.pluck('previousElementSibling')).filter(seletor || '*') },
      next: function(seletor){ return $(this.pluck('nextElementSibling')).filter(seletor || '*') },
      html: function(html){
        retornar 0 em argumentos?
          this.each(função(idx){
            var originHtml = this.innerHTML
            $(this).empty().append(funcArg(this, html, idx, originHtml) )
          }):
          (0 neste ? this[0].innerHTML: nulo)
      },
      texto: função(texto){
        retornar 0 em argumentos?
          this.each(função(idx){
            var newText = funcArg(this, text, idx, this.textContent)
            this.textContent = newText == null ? '': ''+novoTexto
          }):
          (0 neste ? this.pluck('textContent').join("") : null)
      },
      atr: function(nome, valor){
        var resultado
        return (typeof name == 'string' && !(1 em argumentos)) ?
          (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result: undefined) :
          this.each(função(idx){
            if (this.nodeType !== 1) retornar
            if (isObject(name)) for (chave no nome) setAttribute(this, key, name[key])
            else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))
          })
      },
      removeAttr: function(nome){
        return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){
          setAttribute(este, atributo)
        }, esse)})
      },
      prop: function(nome, valor){
        nome = propMap[nome] || nome
        return (1 em argumentos) ?
          this.each(função(idx){
            este[nome] = funcArg(este, valor, idx, este[nome])
          }):
          (este[0] && este[0][nome])
      },
      removeProp: function(nome){
        nome = propMap[nome] || nome
        return this.each(function(){ delete this[name] })
      },
      dados: função(nome, valor){
        var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()

        var data = (1 em argumentos) ?
          this.attr(attrName, valor):
          this.attr(attrName)

        dados de retorno!== null ? desserializeValue(data): indefinido
      },
      val: função(valor){
        if (0 em argumentos) {
          if (valor == nulo) valor = ""
          return this.each(function(idx){
            this.value = funcArg(this, value, idx, this.value)
          })
        } outro {
          return this[0] && (this[0].multiple ?
             $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value'):
             este[0].valor)
        }
      },
      offset: function(coordenadas){
        if (coordenadas) return this.each(function(index){
          var $este = $(este),
              coords = funcArg(este, coordenadas, índice, $este.offset()),
              parentOffset = $this.offsetParent().offset(),
              adereços = {
                superior: coords.top - parentOffset.top,
                esquerda: coords.left - parentOffset.left
              }

          if ($this.css('position') == 'static') props['position'] = 'relative'
          $this.css(adereços)
        })
        if (!this.length) retornar nulo
        if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))
          retornar {topo: 0, esquerda: 0}
        var obj = this[0].getBoundingClientRect()
        retornar {
          esquerda: obj.esquerda + janela.pageXOffset,
          topo: obj.top + window.pageYOffset,
          largura: Math.round(obj.width),
          altura: Math.round(obj.height)
        }
      },
      css: function(propriedade, valor){
        if (argumentos.comprimento < 2) {
          var elemento = este[0]
          if (tipo de propriedade == 'string') {
            if (!elemento) retornar
            return element.style[camelize(propriedade)] || getComputedStyle(elemento, '').getPropertyValue(propriedade)
          } else if (isArray(propriedade)) {
            if (!elemento) retornar
            var adereços = {}
            var estilocomputado = getestilocomputado(elemento, '')
            $.each(propriedade, função(_, propriedade){
              props[prop] = (element.style[camelize(prop)] || computeredStyle.getPropertyValue(prop))
            })
            adereços de retorno
          }
        }

        var css = ''
        if (tipo(propriedade) == 'string') {
          if (!valor && valor !== 0)
            this.each(function(){ this.style.removeProperty(dasherize(propriedade)) })
          outro
            css = dasherize(propriedade) + ":" + mayAddPx(propriedade, valor)
        } outro {
          for (chave na propriedade)
            if (!propriedade[chave] && propriedade[chave] !== 0)
              this.each(function(){ this.style.removeProperty(dasherize(key)) })
            outro
              css += dasherize(chave) + ':' + mayAddPx(chave, propriedade[chave]) + ';'
        }

        return this.each(function(){ this.style.cssText += ';' + css })
      },
      índice: função(elemento){
        elemento de retorno? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])
      },
      hasClass: função(nome){
        if (!name) retornar falso
        return emptyArray.some.call(this, function(el){
          return this.test(className(el))
        }, classeRE(nome))
      },
      addClass: função(nome){
        if (!name) retorna isso
        return this.each(function(idx){
          if (!('className' neste)) return
          listaclasse = []
          var cls = className(this), newName = funcArg(this, name, idx, cls)
          newName.split(/\s+/g).forEach(function(klass){
            if (!$(this).hasClass(klass)) classList.push(klass)
          }, esse)
          classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "))
        })
      },
      removeClass: função(nome){
        return this.each(function(idx){
          if (!('className' neste)) return
          if (nome === indefinido) return className(this, '')
          classList = className(this)
          funcArg(this, name, idx, classList).split(/\s+/g).forEach(function(klass){
            classList = classList.replace(classRE(klass), " ")
          })
          className(this, classList.trim())
        })
      },
      toggleClass: function(nome, quando){
        if (!name) retorna isso
        return this.each(function(idx){
          var $this = $(this), nomes = funcArg(this, name, idx, className(this))
          nomes.split(/\s+/g).forEach(function(klass){
            (quando === indefinido ? !$this.hasClass(klass): quando) ?
              $this.addClass(classe) : $this.removeClass(classe)
          })
        })
      },
      scrollTop: function(valor){
        if (!this.length) return
        var hasScrollTop = 'scrollTop' neste[0]
        if (valor === indefinido) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset
        return this.each(hasScrollTop ?
          function(){ this.scrollTop = valor } :
          function(){ this.scrollTo(this.scrollX, valor) })
      },
      scrollEsquerda: função(valor){
        if (!this.length) return
        var hasScrollLeft = 'scrollLeft' neste[0]
        if (valor === indefinido) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset
        return this.each(hasScrollLeft ?
          function(){ this.scrollLeft = value } :
          function(){ this.scrollTo(value, this.scrollY) })
      },
      posição: function() {
        if (!this.length) return

        var elem = this[0],
          // Obtém *real* offsetParent
          offsetParent = this.offsetParent(),
          // Obtém compensações corretas
          offset = this.offset(),
          parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { topo: 0, esquerda: 0 } : offsetParent.offset()

        // Subtrai as margens do elemento
        // nota: quando um elemento tem margem: auto o offsetLeft e marginLeft
        // são os mesmos no Safari fazendo com que offset.left seja incorretamente 0
        offset.top -= parseFloat( $(elem).css('margin-top') ) || 0
        offset.left -= parseFloat( $(elem).css('margin-left') ) || 0

        // Adiciona bordas offsetParent
        parentOffset.top += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0
        parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0

        // Subtrai os dois offsets
        retornar {
          superior: offset.top - parentOffset.top,
          esquerda: offset.left - parentOffset.left
        }
      },
      offsetParent: function() {
        return this.map(function(){
          var pai = this.offsetParent || documento.corpo
          while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static")
            pai = pai.offsetParent
          pai de retorno
        })
      }
    }

    // por agora
    $.fn.detach = $.fn.remove

    // Gera as funções `width` e `height`
    ;['largura', 'altura'].forEach(função(dimensão){
      var dimensãoPropriedade =
        dimension.replace(/./, function(m){ return m[0].toUpperCase() })

      $.fn[dimensão] = função(valor){
        var offset, el = this[0]
        if (valor === indefinido) return isWindow(el) ? el['inner' + dimensionProperty]:
          isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :
          (offset = this.offset()) && offset[dimensão]
        senão retorne this.each(função(idx){
          el = $(este)
          el.css(dimension, funcArg(this, value, idx, el[dimension]()))
        })
      }
    })

    função traverseNode(nó, diversão) {
      divertido(nó)
      for (var i = 0, len = node.childNodes.length; i < len; i++)
        traverseNode(node.childNodes[i], diversão)
    }

    // Gera o `after`, `prepend`, `before`, `append`,
    // métodos `insertAfter`, `insertBefore`, `appendTo` e `prependTo`.
    adjacencyOperators.forEach(function(operator, operatorIndex) {
      var inside = operatorIndex % 2 //=> preceder, anexar

      $.fn[operador] = função(){
        // argumentos podem ser nós, arrays de nós, objetos Zepto e strings HTML
        var argType, nós = $.map(argumentos, função(arg) {
              var arr = []
              argTipo = tipo(arg)
              if (argType == "array") {
                arg.forEach(função(el) {
                  if (el.nodeType !== indefinido) return arr.push(el)
                  else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())
                  arr = arr.concat(zepto.fragment(el))
                })
                retorno arr
              }
              return argType == "objeto" || arg == nulo ?
                arg : zepto.fragment(arg)
            }),
            pai, copyByClone = this.length > 1
        if (nodes.length < 1) retorna isso

        return this.each(function(_, target){
          pai = dentro? alvo: target.parentNode

          // converte todos os métodos para uma operação "antes"
          alvo = operadorIndex == 0 ? target.nextIrmão :
                   operadorIndex == 1 ? target.firstChild :
                   operadorIndex == 2 ? alvo :
                   nulo

          var parentInDocument = $.contains(document.documentElement, parent)

          nodes.forEach(function(node){
            if (copyByClone) node = node.cloneNode(true)
            else if (!parent) return $(node).remove()

            parent.insertBefore(node, target)
            if (parentInDocument) traverseNode(node, function(el){
              if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&
                 (!el.type || el.type === 'texto/javascript') && !el.src){
                var target = el.ownerDocument ? el.ownerDocument.defaultView: janela
                target['eval'].call(target, el.innerHTML)
              }
            })
          })
        })
      }

      // depois => inserirDepois
      // prepend => prependTo
      // antes => inserirAntes
      // anexar => anexarTo
      $.fn[dentro? operator+'To' : 'insert'+(operatorIndex ? 'Antes' : 'Depois')] = function(html){
        $(html)[operador](este)
        devolva isso
      }
    })

    zepto.Z.prototype = Z.prototype = $.fn

    // Exporta funções internas da API no namespace `$.zepto`
    zepto.uniq = uniq
    zepto.deserializeValue = desserializeValue
    $.zepto = zepto

    devolver $
  })()

  window.Zepto = Zepto
  window.$ === undefined && (window.$ = Zepto)

  ;(função($){
    var _zid = 1, indefinido,
        fatia = Array.prototype.slice,
        isFunction = $.isFunction,
        isString = function(obj){ return typeof obj == 'string' },
        manipuladores = {},
        eventos especiais={},
        focusinSupported = 'onfocusin' na janela,
        focus = { focus: 'focusin', blur: 'focusout' },
        hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }

    specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'

    função zid(elemento) {
      elemento de retorno._zid || (elemento._zid = _zid++)
    }
    function findHandlers(elemento, evento, fn, seletor) {
      event = parse(evento)
      if (event.ns) var matcher = matcherFor(event.ns)
      return (manipuladores[zid(elemento)] || []).filter(função(manipulador) {
        manipulador de retorno
          && (!evento.e || manipulador.e == evento.e)
          && (!event.ns || matcher.test(handler.ns))
          && (!fn || zid(manipulador.fn) === zid(fn))
          && (!seletor || manipulador.sel == seletor)
      })
    }
    function parse(evento) {
      var partes = ('' + evento).split('.')
      return {e: partes[0], ns: partes.slice(1).sort().join(' ')}
    }
    function matcherFor(ns) {
      return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')
    }

    function eventCapture(manipulador, captureSetting) {
      return handler.del &&
        (!focusinSupported && (handler.e em foco)) ||
        !!captureSetting
    }

    função realEvent(tipo) {
      retornar hover[tipo] || (focusinSupported && focus[tipo]) || tipo
    }

    função add(elemento, eventos, fn, dados, seletor, delegador, captura){
      var id = zid(elemento), set = (manipuladores[id] || (manipuladores[id] = []))
      eventos.split(/\s/).forEach(função(evento){
        if (evento == 'pronto') return $(documento).pronto(fn)
        var handler = parse(evento)
        manipulador.fn = fn
        handler.sel = seletor
        // emula mouseenter, mouseleave
        if (handler.e em hover) fn = function(e){
          var relacionado = e.relatedTarget
          if (!relacionado || (relacionado !== este && !$.contains(este, relacionado)))
            return handler.fn.apply(este, argumentos)
        }
        handler.del = delegante
        var callback = delegador || fn
        manipulador.proxy = função(e){
          e = compatível(e)
          if (e.isImmediatePropagationStopped()) retornar
          e.dados = dados
          var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))
          if (resultado === false) e.preventDefault(), e.stopPropagation()
          resultado de retorno
        }
        manipulador.i = conjunto.comprimento
        set.push(manipulador)
        if ('addEventListener' no elemento)
          element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
      })
    }
    function remove(elemento, eventos, fn, seletor, captura){
      var id = zid(elemento)
      ;(eventos || '').split(/\s/).forEach(função(evento){
        findHandlers(elemento, evento, fn, seletor).forEach(função(manipulador){
          excluir manipuladores[id][handler.i]
        if ('removeEventListener' no elemento)
          element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))
        })
      })
    }

    $.evento = { adicionar: adicionar, remover: remover }

    $.proxy = função(fn, contexto) {
      var args = (2 em argumentos) && slice.call(argumentos, 2)
      if (éFunção(fn)) {
        var proxyFn = function(){ return fn.apply(contexto, args ? args.concat(slice.call(argumentos)) : argumentos) }
        proxyFn._zid = zid(fn)
        retornar proxyFn
      } else if (isString(contexto)) {
        if (arg) {
          args.unshift(fn[contexto], fn)
          return $.proxy.apply(null, args)
        } outro {
          return $.proxy(fn[contexto], fn)
        }
      } outro {
        throw new TypeError("função esperada")
      }
    }

    $.fn.bind = function(evento, dados, callback){
      return this.on(evento, dados, callback)
    }
    $.fn.unbind = function(evento, callback){
      return this.off(evento, callback)
    }
    $.fn.one = function(evento, seletor, dados, callback){
      return this.on(evento, seletor, dados, callback, 1)
    }

    var returnTrue = function(){return true},
        returnFalse = function(){return false},
        ignoreProperties = /^([AZ]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
        eventMethods = {
          preventDefault: 'isDefaultPrevented',
          stopImmediatePropagation: 'isImmediatePropagationStopped',
          stopPropagation: 'isPropagationStopped'
        }

    função compatível(evento, fonte) {
      if (origem || !event.isDefaultPrevented) {
        fonte || (fonte = evento)

        $.each(eventMethods, function(nome, predicado) {
          var sourceMethod = source[nome]
          evento[nome] = função(){
            this[predicado] = returnTrue
            return sourceMethod && sourceMethod.apply(fonte, argumentos)
          }
          evento[predicado] = returnFalse
        })

        event.timeStamp || (event.timeStamp = Date.now())

        if (source.defaultPrevented !== indefinido ? source.defaultPrevented :
            'returnValue' na fonte? source.returnValue === false :
            source.getPreventDefault && source.getPreventDefault())
          event.isDefaultPrevented = returnTrue
      }
      evento de retorno
    }

    função criarProxy(evento) {
      chave var, proxy = { originalEvent: evento }
      para (tecla no evento)
        if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]

      retorno compatível (proxy, evento)
    }

    $.fn.delegate = function(seletor, evento, callback){
      return this.on(evento, seletor, callback)
    }
    $.fn.undelegate = function(seletor, evento, callback){
      return this.off(evento, seletor, callback)
    }

    $.fn.live = function(evento, callback){
      $(document.body).delegate(this.selector, evento, callback)
      devolva isso
    }
    $.fn.die = function(evento, callback){
      $(document.body).undelegate(this.selector, evento, callback)
      devolva isso
    }

    $.fn.on = function(evento, seletor, dados, callback, um){
      var autoRemove, delegador, $this = this
      if (evento && !isString(evento)) {
        $.each(evento, função(tipo, fn){
          $this.on(tipo, seletor, dados, fn, um)
        })
        devolver $este
      }

      if (!isString(seletor) && !isFunction(callback) && callback !== false)
        retorno de chamada = dados, dados = seletor, seletor = indefinido
      if (callback === indefinido || dados === false)
        retorno de chamada = dados, dados = indefinido

      if (callback === false) callback = returnFalse

      return $this.each(função(_, elemento){
        if (um) autoRemove = function(e){
          remove(elemento, e.type, retorno de chamada)
          return callback.apply(this, argumentos)
        }

        if (seletor) delegador = function(e){
          var evt, match = $(e.target).closest(seletor, elemento).get(0)
          if (combinar && combinar !== elemento) {
            evt = $.extend(createProxy(e), {currentTarget: correspondência, liveFired: elemento})
            return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))
          }
        }

        add(elemento, evento, retorno de chamada, dados, seletor, delegador || autoRemove)
      })
    }
    $.fn.off = function(evento, seletor, callback){
      var $este = este
      if (evento && !isString(evento)) {
        $.each(evento, função(tipo, fn){
          $this.off(tipo, seletor, fn)
        })
        devolver $este
      }

      if (!isString(seletor) && !isFunction(callback) && callback !== false)
        callback = seletor, seletor = indefinido

      if (callback === false) callback = returnFalse

      return $this.each(função(){
        remove(este, evento, retorno de chamada, seletor)
      })
    }

    $.fn.trigger = function(evento, argumentos){
      evento = (isString(evento) || $.isPlainObject(evento)) ? $.Event(evento): compatível(evento)
      event._args = args
      return this.each(function(){
        // lida com focus(), blur() chamando-os diretamente
        if (event.type em foco && typeof this[event.type] == "função") this[event.type]()
        // itens na coleção podem não ser elementos DOM
        else if ('dispatchEvent' neste) this.dispatchEvent(event)
        else $(this).triggerHandler(evento, args)
      })
    }

    // aciona manipuladores de eventos no elemento atual como se um evento tivesse ocorrido,
    // não aciona um evento real, não borbulha
    $.fn.triggerHandler = function(evento, argumentos){
      var e, resultado
      this.each(função(i, elemento){
        e = createProxy(isString(evento) ? $.Event(evento): evento)
        e._args = args
        e.alvo = elemento
        $.each(findHandlers(elemento, evento.tipo || evento), função(i, manipulador){
          resultado = manipulador.proxy(e)
          if (e.isImmediatePropagationStopped()) retornar falso
        })
      })
      resultado de retorno
    }

    // métodos de atalho para `.bind(event, fn)` para cada tipo de evento
    ;('focusin focusout foco borrão carregar redimensionar scroll descarregar click dblclick '+
    'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+
    'alterar erro de seleção de tecla pressionada tecla pressionada').split(' ').forEach(function(event) {
      $.fn[evento] = function(callback) {
        return (0 em argumentos) ?
          this.bind(evento, retorno de chamada):
          this.trigger(evento)
      }
    })

    $.Event = function(tipo, props) {
      if (!isString(tipo)) props = tipo, type = props.type
      var event = document.createEvent(specialEvents[type] || 'Eventos'), bolhas = true
      if (props) for (nome da var em props) (nome == 'bolhas') ? (bubbles = !!props[nome]) : (evento[nome] = props[nome])
      event.initEvent(tipo, bolhas, verdadeiro)
      retorno compatível (evento)
    }

  })(Zepto)

  ;(função($){
    var jsonpID = +nova Data(),
        documento = janela.documento,
        chave,
        nome,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        scriptTypeRE = /^(?:texto|aplicativo)\/javascript/i,
        xmlTypeRE = /^(?:texto|aplicativo)\/xml/i,
        jsonType = 'aplicativo/json',
        htmlType = 'texto/html',
        blankRE = /^\s*$/,
        originAnchor = document.createElement('a')

    originAnchor.href = window.location.href

    // dispara um evento customizado e retorna false se foi cancelado
    function triggerAndReturn(context, eventName, data) {
      var event = $.Event(eventName)
      $(contexto).trigger(evento, dados)
      return !event.isDefaultPrevented()
    }

    // dispara um evento Ajax "global"
    function triggerGlobal(configurações, contexto, eventName, dados) {
      if (settings.global) return triggerAndReturn(context || document, eventName, data)
    }

    // Número de solicitações Ajax ativas
    $.ativo = 0

    function ajaxStart(configurações) {
      if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')
    }
    function ajaxStop(configurações) {
      if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')
    }

    // aciona um evento global extra "ajaxBeforeSend" que é como "ajaxSend", mas cancelável
    function ajaxBeforeSend(xhr, configurações) {
      var contexto = configurações.contexto
      if (settings.beforeSend.call(context, xhr, settings) === false ||
          triggerGlobal(configurações, contexto, 'ajaxBeforeSend', [xhr, configurações]) === false)
        retorna falso

      triggerGlobal(configurações, contexto, 'ajaxSend', [xhr, configurações])
    }
    function ajaxSuccess(dados, xhr, configurações, adiado) {
      var context = settings.context, status = 'sucesso'
      settings.success.call(contexto, dados, status, xhr)
      if (adiado) deferred.resolveWith(contexto, [dados, status, xhr])
      triggerGlobal(configurações, contexto, 'ajaxSuccess', [xhr, configurações, dados])
      ajaxComplete(status, xhr, configurações)
    }
    // tipo: "timeout", "error", "abort", "parsererror"
    function ajaxError(erro, tipo, xhr, configurações, adiado) {
      var contexto = configurações.contexto
      settings.error.call(contexto, xhr, tipo, erro)
      if (adiado) deferred.rejectWith(contexto, [xhr, tipo, erro])
      triggerGlobal(configurações, contexto, 'ajaxError', [xhr, configurações, erro || tipo])
      ajaxComplete(tipo, xhr, configurações)
    }
    // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
    função ajaxComplete(status, xhr, configurações) {
      var contexto = configurações.contexto
      settings.complete.call(context, xhr, status)
      triggerGlobal(configurações, contexto, 'ajaxComplete', [xhr, configurações])
      ajaxStop(configurações)
    }

    função ajaxDataFilter(dados, tipo, configurações) {
      if (settings.dataFilter == vazio) retorna dados
      var contexto = configurações.contexto
      return settings.dataFilter.call(contexto, dados, tipo)
    }

    // Função vazia, usada como callback padrão
    função vazia() {}

    $.ajaxJSONP = function(opções, adiada){
      if (!('digite' nas opções)) return $.ajax(opções)

      var _callbackName = opções.jsonpCallback,
        callbackName = ($.isFunction(_callbackName) ?
          _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),
        script = document.createElement('script'),
        originalCallback = janela[callbackName],
        respostaData,
        abort = function(errorType) {
          $(script).triggerHandler('erro', errorType || 'abortar')
        },
        xhr = { abortar: abortar }, abortTimeout

      if (adiado) deferred.promise(xhr)

      $(script).on('erro de carregamento', function(e, errorType){
        clearTimeout(abortTimeout)
        $(script).off().remove()

        if (e.type == 'erro' || !responseData) {
          ajaxError(null, errorType || 'erro', xhr, opções, adiado)
        } outro {
          ajaxSuccess(responseData[0], xhr, opções, adiado)
        }

        window[callbackName] = originalCallback
        if (responseData && $.isFunction(originalCallback))
          originalCallback(responseData[0])

        originalCallback = responseData = indefinido
      })

      if (ajaxBeforeSend(xhr, opções) === false) {
        abortar('abortar')
        retornar xhr
      }

      janela[callbackName] = function(){
        responseData = argumentos
      }

      script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName)
      document.head.appendChild(script)

      if (options.timeout > 0) abortTimeout = setTimeout(function(){
        abort('timeout')
      }, opções.timeout)

      retornar xhr
    }

    $.ajaxSettings = {
      // Tipo padrão de requisição
      tipo: 'GET',
      // Callback que é executado antes da requisição
      antesEnviar: vazio,
      // Callback que é executado se a requisição for bem-sucedida
      sucesso: vazio,
      // Callback que é executado no erro de queda do servidor
      erro: vazio,
      // Callback que é executado na solicitação completa (ambos: erro e sucesso)
      completo: vazio,
      // O contexto para os retornos de chamada
      contexto: nulo,
      // Se deve acionar eventos Ajax "globais"
      global: verdadeiro,
      // Transporte
      xhr: função () {
        retornar nova janela.XMLHttpRequest()
      },
      // mapeamento de tipos MIME
      // IIS retorna Javascript como "application/x-javascript"
      aceita: {
        script: 'texto/javascript, aplicativo/javascript, aplicativo/x-javascript',
        json: jsonType,
        xml: 'aplicativo/xml, texto/xml',
        html: htmlTipo,
        texto: 'texto/simples'
      },
      // Se a requisição é para outro domínio
      crossDomain: falso,
      // tempo limite padrão
      tempo limite: 0,
      // Se os dados devem ser serializados para string
      processData: verdadeiro,
      // Se o navegador deve ter permissão para armazenar respostas GET em cache
      cache: verdadeiro,
      //Usado para lidar com os dados brutos de resposta de XMLHttpRequest.
      //Esta é uma função de pré-filtragem para limpar a resposta.
      //A resposta higienizada deve ser retornada
      dataFilter: vazio
    }

    function mimeToDataType(mime) {
      if (mime) mime = mime.split(';', 2)[0]
      return mime && ( mime == htmlType ? 'html' :
        mime == jsonType ? 'json':
        scriptTypeRE.test(mime) ? 'roteiro' :
        xmlTypeRE.test(mime) && 'xml' ) || 'texto'
    }

    function appendQuery(url, query) {
      if (consulta == '') url de retorno
      return (url + '&' + consulta).replace(/[&?]{1,2}/, '?')
    }

    // serializar o payload e anexá-lo ao URL para solicitações GET
    função serializeData(opções) {
      if (options.processData && options.data && $.type(options.data) != "string")
        opções.data = $.param(opções.dados, opções.tradicional)
      if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))
        options.url = appendQuery(options.url, options.data), options.data = indefinido
    }

    $.ajax = função(opções){
      configurações var = $.extend({}, opções || {}),
          adiado = $.Adiado && $.Adiado(),
          urlAnchor, hashIndex
      for (chave em $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]

      ajaxStart(configurações)

      if (!configurações.crossDomain) {
        urlAnchor = document.createElement('a')
        urlAnchor.href = configurações.url
        // limpa URL para .href (somente IE), consulte https://github.com/madrobby/zepto/pull/1049
        urlAnchor.href = urlAnchor.href
        settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)
      }

      if (!settings.url) settings.url = window.location.toString()
      if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)
      serializeData(configurações)

      var dataType = settings.dataType, hasPlaceholder = /\?.+=\?/.test(settings.url)
      if (hasPlaceholder) dataType = 'jsonp'

      if (configurações.cache === false || (
           (!options || options.cache !== true) &&
           ('script' == dataType || 'jsonp' == dataType)
          ))
        settings.url = appendQuery(settings.url, '_=' + Date.now())

      if ('jsonp' == dataType) {
        if (!hasPlaceholder)
          settings.url = appendQuery(settings.url,
            settings.jsonp ? (settings.jsonp + '=?'): settings.jsonp === false ? '' : 'chamada de retorno =?')
        return $.ajaxJSONP(configurações, diferido)
      }

      var mime = settings.accepts[dataType],
          cabeçalhos = { },
          setHeader = function(nome, valor) { headers[name.toLowerCase()] = [nome, valor] },
          protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
          xhr = configurações.xhr(),
          nativeSetHeader = xhr.setRequestHeader,
          abortTimeout

      if (adiado) deferred.promise(xhr)

      if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')
      setHeader('Aceitar', mime || '*/*')
      if (mime = settings.mimeType || mime) {
        if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]
        xhr.overrideMimeType && xhr.overrideMimeType(mime)
      }
      if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))
        setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')

      if (settings.headers) for (nome em settings.headers) setHeader(name, settings.headers[name])
      xhr.setRequestHeader = setHeader

      xhr.onreadystatechange = function(){
        if (xhr.readyState == 4) {
          xhr.onreadystatechange = vazio
          clearTimeout(abortTimeout)
          var resultado, erro = false
          if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocolo == 'arquivo:')) {
            dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))

            if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')
              resultado = xhr.resposta
            outro {
              resultado = xhr.responseText

              tentar {
                // http://perfectionkills.com/global-eval-what-are-the-options/
                // limpa a resposta adequadamente se o retorno de chamada do filtro de dados for fornecido
                resultado = ajaxDataFilter(resultado, tipo de dados, configurações)
                if (dataType == 'script') (1,eval)(resultado)
                else if (dataType == 'xml') resultado = xhr.responseXML
                else if (dataType == 'json') resultado = blankRE.test(resultado) ? null : $.parseJSON(resultado)
              } catch (e) { erro = e }

              if (erro) return ajaxError(erro, 'parsererror', xhr, configurações, adiado)
            }

            ajaxSuccess(resultado, xhr, configurações, adiado)
          } outro {
            ajaxError(xhr.statusText || nulo, xhr.status ? 'erro' : 'abortar', xhr, configurações, adiado)
          }
        }
      }

      if (ajaxBeforeSend(xhr, configurações) === false) {
        xhr.abort()
        ajaxError(nulo, 'abortar', xhr, configurações, adiado)
        retornar xhr
      }

      var async = 'async' nas configurações? configurações.async: verdadeiro
      xhr.open(settings.type, settings.url, async, settings.username, settings.password)

      if (settings.xhrFields) for (nome em settings.xhrFields) xhr[name] = settings.xhrFields[name]

      for (nome nos cabeçalhos) nativeSetHeader.apply(xhr, cabeçalhos[nome])

      if (settings.timeout > 0) abortTimeout = setTimeout(function(){
          xhr.onreadystatechange = vazio
          xhr.abort()
          ajaxError(null, 'timeout', xhr, configurações, adiado)
        }, settings.timeout)

      // evita enviar string vazia (#319)
      xhr.send(settings.data ? settings.data : null)
      retornar xhr
    }

    // manipula dados opcionais/argumentos de sucesso
    function parseArguments(url, data, success, dataType) {
      if ($.isFunction(data)) dataType = sucesso, sucesso = dados, dados = indefinido
      if (!$.isFunction(success)) dataType = sucesso, sucesso = indefinido
      retornar {
        url: url
      , dados: dados
      , sucesso: sucesso
      , tipo de dados: tipo de dados
      }
    }

    $.get = function(/* url, data, success, dataType */){
      return $.ajax(parseArguments.apply(nulo, argumentos))
    }

    $.post = function(/* url, data, success, dataType */){
      var opções = parseArguments.apply(nulo, argumentos)
      opções.tipo = 'POST'
      return $.ajax(opções)
    }

    $.getJSON = function(/* url, dados, sucesso */){
      var opções = parseArguments.apply(nulo, argumentos)
      opções.dataType = 'json'
      return $.ajax(opções)
    }

    $.fn.load = function(url, dados, sucesso){
      if (!this.length) retorna isso
      var self = this, parts = url.split(/\s/), seletor,
          opções = parseArguments(url, dados, sucesso),
          retorno de chamada = opções.sucesso
      if (parts.length > 1) options.url = parts[0], selector = parts[1]
      opções.sucesso = função(resposta){
        self.html(seletor ?
          $('<div>').html(response.replace(rscript, "")).find(seletor)
          : resposta)
        retorno de chamada && retorno de chamada.apply(self, argumentos)
      }
      $.ajax(opções)
      devolva isso
    }

    var escape = encodeURIComponent

    função serialize(params, obj, tradicional, escopo){
      tipo var, array = $.isArray(obj), hash = $.isPlainObject(obj)
      $.each(obj, função(chave, valor) {
        tipo = $.tipo(valor)
        if (escopo) chave = tradicional? escopo :
          scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'
        // trata os dados no formato serializeArray()
        if (!scope && array) params.add(value.name, value.value)
        // recursiva em objetos aninhados
        else if (tipo == "array" || (!tradicional && tipo == "objeto"))
          serialize(parâmetros, valor, tradicional, chave)
        else params.add(chave, valor)
      })
    }

    $.param = function(obj, tradicional){
      var parâmetros = []
      params.add = function(chave, valor) {
        if ($.isFunction(valor)) valor = valor()
        if (valor == nulo) valor = ""
        this.push(escape(chave) + '=' + escape(valor))
      }
      serialize(params, obj, tradicional)
      return params.join('&').replace(/%20/g, '+')
    }
  })(Zepto)

  ;(função($){
    $.fn.serializeArray = function() {
      var nome, tipo, resultado = [],
        adicionar = função(valor) {
          if (value.forEach) return value.forEach(add)
          result.push({ nome: nome, valor: valor })
        }
      if (este[0]) $.each(este[0].elementos, função(_, campo){
        tipo = campo.tipo, nome = campo.nome
        if (nome && field.nodeName.toLowerCase() != 'fieldset' &&
          !field.disabled && digite != 'enviar' && digite != 'redefinir' && digite != 'botão' && digite != 'arquivo' &&
          ((digite != 'rádio' && digite != 'caixa de seleção') || field.checked))
            add($(campo).val())
      })
      resultado de retorno
    }

    $.fn.serialize = function(){
      var resultado = []
      this.serializeArray().forEach(function(elm){
        result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))
      })
      return result.join('&')
    }

    $.fn.submit = function(callback) {
      if (0 em argumentos) this.bind('enviar', retorno de chamada)
      else if (este.comprimento) {
        var evento = $.Event('enviar')
        this.eq(0).trigger(evento)
        if (!event.isDefaultPrevented()) this.get(0).submit()
      }
      devolva isso
    }

  })(Zepto)

  ;(função(){
    // getComputedStyle não deve surtar quando chamado
    // sem um elemento válido como argumento
    tentar {
      getComputedStyle(indefinido)
    } pegar(e) {
      var nativeGetComputedStyle = getComputedStyle
      window.getComputedStyle = function(elemento, pseudoElemento){
        tentar {
          return nativeGetComputedStyle(elemento, pseudoElemento)
        } pegar(e) {
          retornar nulo
        }
      }
    }
  })()
    retorno Zepto
  }))